package com.goplay.codegen;

import java.io.*;
import java.nio.file.*;
import java.util.*;

/**
 * Generates Java client code from route configuration.
 * Similar to the TypeScript protocol extension generator.
 */
public class JavaCodeGenerator {

    private RouteConfig config;
    private StringBuilder code;

    public JavaCodeGenerator(RouteConfig config) {
        this.config = config;
        this.code = new StringBuilder();
    }

    public String generate() {
        generateHeader();
        generateImports();
        generateClassDeclaration();
        generateRouteConstants();
        generatePushConstants();
        generateRouteMethods();
        generateClassEnd();
        generateResultInterfaces();

        return code.toString();
    }

    private void generateHeader() {
        code.append("// Code generated by GoPlay Protocol Extension Generator. DO NOT EDIT.\n");
        code.append("package ").append(config.getPackageName()).append(";\n\n");
    }

    private void generateImports() {
        code.append("import com.goplay.GoPlay;\n");
        code.append("import java.util.concurrent.CompletableFuture;\n");

        // Add protobuf package imports
        if (config.getProtobufPackage() != null) {
            code.append("import ").append(config.getProtobufPackage()).append(".*;\n");
        }

        code.append("\n");
    }

    private void generateClassDeclaration() {
        code.append("/**\n");
        code.append(" * Auto-generated GoPlay client with strongly-typed API methods.\n");
        code.append(" * Wraps GoPlay framework with convenient async methods for each route.\n");
        code.append(" */\n");
        code.append("public class ").append(config.getClassName()).append(" {\n\n");
    }

    private void generateRouteConstants() {
        code.append("    // Route mappings\n");
        code.append("    public static class Routes {\n");

        for (Map.Entry<String, RouteConfig.RouteInfo> entry : config.getRoutes().entrySet()) {
            String key = entry.getKey();
            String route = entry.getValue().route;
            code.append("        public static final String ").append(key)
                    .append(" = \"").append(route).append("\";\n");
        }

        code.append("    }\n\n");
    }

    private void generatePushConstants() {
        if (config.getPushes().isEmpty()) return;

        code.append("    // Push event mappings\n");
        code.append("    public static class Pushes {\n");

        for (Map.Entry<String, RouteConfig.PushInfo> entry : config.getPushes().entrySet()) {
            String key = entry.getKey();
            String pushKey = entry.getValue().pushKey;
            code.append("        public static final String ").append(key)
                    .append(" = \"").append(pushKey).append("\";\n");
        }

        code.append("    }\n\n");
    }

    private void generateRouteMethods() {
        code.append("    // Auto-generated API methods\n\n");

        for (Map.Entry<String, RouteConfig.RouteInfo> entry : config.getRoutes().entrySet()) {
            RouteConfig.RouteInfo route = entry.getValue();
            generateRouteMethod(route);
        }
    }

    private void generateRouteMethod(RouteConfig.RouteInfo route) {
        String methodName = route.methodName;
        String requestType = route.hasRequest ? route.requestType : null;
        String responseType = route.hasResponse ? route.responseType : "Void";
        String resultType = methodName + "Result";

        code.append("    /**\n");
        code.append("     * Route: ").append(route.route).append("\n");
        if (requestType != null) {
            code.append("     * @param request Request data\n");
        }
        code.append("     * @return CompletableFuture with typed response\n");
        code.append("     */\n");

        code.append("    public static CompletableFuture<").append(resultType).append("> ");
        code.append(methodName).append("(");

        if (requestType != null) {
            code.append(getSimpleClassName(requestType)).append(" request");
        }

        code.append(") {\n");

        // Method body
        code.append("        return GoPlay.request(\"").append(route.route).append("\", ");
        code.append(requestType != null ? "request" : "null").append(", ");

        if (route.hasResponse) {
            code.append(getSimpleClassName(responseType)).append(".class");
        } else {
            code.append("Void.class");
        }

        code.append(")\n");
        code.append("            .thenApply(resp -> {\n");
        code.append("                ").append(resultType).append(" result = new ").append(resultType).append("();\n");
        code.append("                result.status = resp.status;\n");
        code.append("                result.data = resp.data;\n");
        code.append("                return result;\n");
        code.append("            });\n");
        code.append("    }\n\n");
    }

    private void generateClassEnd() {
        code.append("}\n\n");
    }

    private void generateResultInterfaces() {
        code.append("// Result type definitions\n\n");

        for (Map.Entry<String, RouteConfig.RouteInfo> entry : config.getRoutes().entrySet()) {
            RouteConfig.RouteInfo route = entry.getValue();
            String resultType = route.methodName + "Result";
            String dataType = route.hasResponse ? getSimpleClassName(route.responseType) : "Void";

            code.append("class ").append(resultType).append(" {\n");
            code.append("    public int status;\n");
            code.append("    public ").append(dataType).append(" data;\n");
            code.append("}\n\n");
        }
    }

    private String getSimpleClassName(String fullClassName) {
        if (fullClassName == null) return "Void";
        int lastDot = fullClassName.lastIndexOf('.');
        return lastDot >= 0 ? fullClassName.substring(lastDot + 1) : fullClassName;
    }

    public void writeToFile(String outputPath) throws IOException {
        Path path = Paths.get(outputPath);
        Files.createDirectories(path.getParent());
        Files.write(path, generate().getBytes());
        System.out.println("Generated: " + outputPath);
    }
}